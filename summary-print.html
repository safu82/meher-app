<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>meher-summary_print.pdf</title>
  <style>
    :root{
      --brand-bg:#ffffff;
      --brand-fg:#1f2937;
      --brand-muted:#6b7280;
      --accent:#8bd3dd;
      --accent-2:#ffd6a5;
      --card:#f7fafc;
      --table-border:#e5e7eb;
    }
    html,body{background:var(--brand-bg); color:var(--brand-fg); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji"; line-height:1.4; }
    .container{max-width: 940px; margin: 0 auto; padding: 16px 20px 64px;}
    h1{font-size:22px; margin:0 0 8px 0}
    .sub{color:var(--brand-muted); font-size:13px; margin-bottom:14px}
    .kpis{display:grid; grid-template-columns: repeat(3, 1fr) repeat(3, 1fr); gap:10px; margin:10px 0 16px}
    .kpi{background:var(--card); border:1px solid var(--table-border); border-radius:12px; padding:10px 12px}
    .kpi .label{font-size:11px; color:var(--brand-muted)}
    .kpi .value{font-size:18px; font-weight:700}
    .chart-card{background:var(--card); border:1px solid var(--table-border); border-radius:12px; padding:12px; margin:6px 0 16px}
    .chart-title{font-size:13px; color:var(--brand-muted); margin-bottom:6px}
    .legend{display:flex; gap:12px; font-size:12px; color:var(--brand-muted); margin:4px 0 0}
    .legend .swatch{display:inline-block; width:10px; height:10px; border-radius:2px; margin-right:6px}
    .table-wrap{overflow:hidden; border:1px solid var(--table-border); border-radius:12px; }
    table{width:100%; border-collapse:collapse; font-size:13px}
    thead th{background:#fbfbfb; text-align:left; padding:10px; border-bottom:1px solid var(--table-border)}
    tbody td{padding:10px; border-bottom:1px solid var(--table-border)}
    tfoot td{padding:10px; font-weight:700; background:#fcfcfc}
    .neg{color:#b91c1c}
    .pos{color:#065f46}
    .highlights{margin:14px 0 8px}
    .highlights h3{font-size:14px; margin:0 0 6px}
    .highlights ul{margin:0; padding-left:18px}
    .muted{color:var(--brand-muted)}
    .filename{font-size:11px; color:var(--brand-muted); margin-top:8px}
    .footer{position:fixed; bottom:8px; left:0; right:0; text-align:center; font-size:11px; color:var(--brand-muted)}
    .footer::after{content:"Page " counter(page) " / " counter(pages);}
    .page-break-avoid{break-inside:avoid}
    .right{float:right}
    @page { size: A4; margin: 12mm; }
    @media print{
      .no-print{display:none !important}
      a { color: inherit; text-decoration: none; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <div class="container">
    <header>
      <h1>Meher Study Summary</h1>
      <div class="sub" id="metaLine">Week: — | Generated: — IST</div>
    </header>

    <section class="kpis page-break-avoid" id="kpis"></section>

    <section class="chart-card page-break-avoid">
      <div class="chart-title">Expected vs Actual by Subject (hours)</div>
      <svg id="barChart" width="900" height="260" role="img" aria-label="Planned vs Actual grouped bars"></svg>
      <div class="legend">
        <div><span class="swatch" style="background:var(--accent)"></span>Expected</div>
        <div><span class="swatch" style="background:var(--accent-2)"></span>Actual</div>
      </div>
    </section>

    <section class="table-wrap page-break-avoid">
      <table id="subjectTable">
        <thead>
          <tr>
            <th>Subject</th>
            <th>Expected (h)</th>
            <th>Actual (h)</th>
            <th>Δ (h)</th>
            <th>% Complete</th>
          </tr>
        </thead>
        <tbody></tbody>
        <tfoot>
          <tr>
            <td>Total</td>
            <td id="tPlanned">0.0</td>
            <td id="tActual">0.0</td>
            <td id="tDelta">0.0</td>
            <td id="tPct">0%</td>
          </tr>
        </tfoot>
      </table>
    </section>

    <section class="highlights page-break-avoid">
      <h3>Highlights</h3>
      <ul id="highlightsList"></ul>
      <div class="filename" id="fileHint"></div>
      <div class="filename" id="dataHint"></div>
    </section>
  </div>

  <div class="footer"></div>

  <script>
    const IST_OFFSET_MIN = 330;
    function toIST(dateUTC=new Date()){ return new Date(dateUTC.getTime() + IST_OFFSET_MIN*60000); }
    function fromIST(istDate){ return new Date(istDate.getTime() - IST_OFFSET_MIN*60000); }
    function isoDateIST(d){
      const ist = toIST(d);
      const y = ist.getFullYear();
      const m = (ist.getMonth()+1).toString().padStart(2,'0');
      const day = ist.getDate().toString().padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
    function formatRangeHuman(isoFrom, isoTo){
      const [fy,fm,fd]=isoFrom.split('-').map(Number);
      const [ty,tm,td]=isoTo.split('-').map(Number);
      const a = new Date(fy, fm-1, fd);
      const b = new Date(ty, tm-1, td);
      const fmt = (d)=> d.toLocaleDateString('en-GB', {day:'2-digit', month:'short', year:'numeric'});
      return `${fmt(a)} – ${fmt(b)}`;
    }
    function computeWeekIST(dateUTC=new Date()){
      const ist = toIST(dateUTC);
      const day = ist.getDay();
      const deltaToMon = (day+6)%7;
      const monIST = new Date(ist.getFullYear(), ist.getMonth(), ist.getDate());
      monIST.setDate(monIST.getDate() - deltaToMon);
      const sunIST = new Date(monIST); sunIST.setDate(monIST.getDate()+6);
      return { from: isoDateIST(fromIST(monIST)), to: isoDateIST(fromIST(sunIST)), monIST, sunIST };
    }

    const MOCK = {
      targetWeeklyHours: 32,
      subjects: [
        { name:'Chemistry', plannedMin: 240, actualMin: 120 },
        { name:'English Lit', plannedMin: 240, actualMin: 192 },
        { name:'Maths', plannedMin: 300, actualMin: 260 },
        { name:'Physics', plannedMin: 180, actualMin: 140 },
        { name:'Biology', plannedMin: 120, actualMin: 90 },
        { name:'History', plannedMin: 180, actualMin: 210 }
      ],
      sessions: 18,
      streakDays: 4,
      bestWeek: { hours: 38.5, from: '2025-08-04', to:'2025-08-10' },
    };

    const EXPECTED_PER_SUBJECT_H = 4; // hours per subject

    function hours(xMin){ return +(xMin/60).toFixed(1); }
    function pct(a,b){ if(b<=0) return 0; return Math.round((a/b)*100); }

    function renderMeta(isoFrom, isoTo){
      const nowIST = toIST(new Date());
      const gen = nowIST.toLocaleString('en-GB',{hour12:false});
      document.getElementById('metaLine').textContent =
        `Week: ${formatRangeHuman(isoFrom, isoTo)} | Generated: ${gen} IST`;
      const filename = `meher-summary_${isoFrom}_to_${isoTo}.pdf`;
      document.title = filename;
      document.getElementById('fileHint').textContent = filename;
    }

    function renderKPIs(data, isoFrom, isoTo){
      const totalExpectedH = data.subjects.length * EXPECTED_PER_SUBJECT_H;
      const totalActualH  = hours(data.subjects.reduce((s,r)=>s+r.actualMin,0));
      const completion = pct(totalActualH, totalExpectedH);
      const best = data.bestWeek;

      const items = [
        ['Expected', `${totalExpectedH.toFixed(1)}h`],
        ['Actual', `${totalActualH}h`],
        ['Completion', `${completion}%`],
        ['Sessions', String(data.sessions)],
        ['Streak', `${data.streakDays}d`],
        ['Best Week So Far', `${best.hours}h (${new Date(best.from).toLocaleDateString('en-GB',{day:'2-digit',month:'short'})}–${new Date(best.to).toLocaleDateString('en-GB',{day:'2-digit',month:'short'})})`],
      ];
      const wrap = document.getElementById('kpis');
      wrap.innerHTML = items.map(([label,val])=>`
        <div class="kpi">
          <div class="label">${label}</div>
          <div class="value">${val}</div>
        </div>
      `).join('');
    }

    function renderTable(data){
      const tbody = document.querySelector('#subjectTable tbody');
      let tExp=0, tAct=0;
      tbody.innerHTML = data.subjects.map(s=>{
        const p = EXPECTED_PER_SUBJECT_H, a = hours(s.actualMin);
        const d = +(a - p).toFixed(1);
        const pc = p>0 ? Math.round((a/p)*100) : 0;
        tExp += p; tAct += a;
        return `<tr>
          <td>${s.name}</td>
          <td>${p.toFixed(1)}</td>
          <td>${a.toFixed(1)}</td>
          <td class="${d<0?'neg':'pos'}">${d>0?'+':''}${d.toFixed(1)}</td>
          <td>${pc}%</td>
        </tr>`;
      }).join('');
      const tDelta = +(tAct - tExp).toFixed(1);
      const tPct = tExp>0 ? Math.round((tAct/tExp)*100) : 0;
      document.getElementById('tPlanned').textContent = tExp.toFixed(1);
      document.getElementById('tActual').textContent  = tAct.toFixed(1);
      document.getElementById('tDelta').textContent   = (tDelta>0?'+':'')+tDelta.toFixed(1);
      document.getElementById('tDelta').className = tDelta<0?'neg':'pos';
      document.getElementById('tPct').textContent     = `${tPct}%`;
    }

    function renderHighlights(data){
      const bullets = [];
      data.subjects.forEach(s=>{
        const p=EXPECTED_PER_SUBJECT_H, a=hours(s.actualMin), d=+(a-p).toFixed(1);
        if(d <= -1) bullets.push(`${s.name} is ${d.toFixed(1)}h vs expected`);
      });
      data.subjects.forEach(s=>{
        const p=EXPECTED_PER_SUBJECT_H, a=hours(s.actualMin);
        if(p>0 && a/p >= 1.1) bullets.push(`${s.name} trending strong at ${Math.round((a/p)*100)}%`);
      });
      bullets.push(`Best day: Wed (6.0h)`);
      const list = document.getElementById('highlightsList');
      list.innerHTML = bullets.slice(0,4).map(b=>`<li>${b}</li>`).join('');
    }

    function renderGroupedBarChart(data){
      const svg = document.getElementById('barChart');
      const width = 900, height = 260;
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.innerHTML = '';
      const leftPad = 140, rightPad = 24, topPad = 10, rowH = 32;
      const chartW = width - leftPad - rightPad;
      const maxHrs = Math.max(1, EXPECTED_PER_SUBJECT_H, ...data.subjects.map(s=>(s.actualMin/60)));
      const barH = 10;

      data.subjects.forEach((s, i)=>{
        const y = topPad + i*(rowH);
        const label = document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x', 0);
        label.setAttribute('y', y + barH + 6);
        label.setAttribute('font-size','12');
        label.textContent = s.name;
        svg.appendChild(label);

        const p = +EXPECTED_PER_SUBJECT_H.toFixed(1), a = +(s.actualMin/60).toFixed(1);
        const pw = (p/maxHrs) * chartW;
        const aw = (a/maxHrs) * chartW;

        const pRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        pRect.setAttribute('x', leftPad);
        pRect.setAttribute('y', y);
        pRect.setAttribute('width', pw);
        pRect.setAttribute('height', barH);
        pRect.setAttribute('rx','3');
        pRect.setAttribute('fill','var(--accent)');
        svg.appendChild(pRect);

        const aRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        aRect.setAttribute('x', leftPad);
        aRect.setAttribute('y', y + barH + 4);
        aRect.setAttribute('width', aw);
        aRect.setAttribute('height', barH);
        aRect.setAttribute('rx','3');
        aRect.setAttribute('fill','var(--accent-2)');
        svg.appendChild(aRect);      });

      const tick0 = document.createElementNS('http://www.w3.org/2000/svg','text');
      tick0.setAttribute('x', leftPad-4); tick0.setAttribute('y', topPad-2);
      tick0.setAttribute('text-anchor','end'); tick0.setAttribute('font-size','11');
      tick0.textContent = 'Hours';
      svg.appendChild(tick0);
    }

    function getQuery(){
      const p = new URLSearchParams(location.search);
      let from = p.get('from'), to = p.get('to');
      if(!from || !to){
        const w = computeWeekIST(new Date());
        from = w.from; to = w.to;
      }
      return {from, to};
    }

    
    // ---------- Supabase config (fill these or pass via URL as ?sbUrl=...&sbKey=...) ----------
    const SB_URL = (new URLSearchParams(location.search).get('sbUrl')) || (localStorage.getItem('SB_URL')) || (window.SUPABASE_URL || "") || "";
    const SB_KEY = (new URLSearchParams(location.search).get('sbKey')) || (localStorage.getItem('SB_KEY')) || (window.SUPABASE_ANON_KEY || "") || "";
    let sb = null;
    try{
      if (SB_URL && SB_KEY && window.supabase && !sb) {
        sb = window.supabase.createClient(SB_URL, SB_KEY);
      }
    }catch(e){ console.warn('Supabase init failed:', e); }
    // Query param overrides for data source
    const QP = new URLSearchParams(location.search);
    const OV_TABLE = QP.get('table') || null;
    const OV_DATECOL = QP.get('datecol') || null;
    const OV_MINSCOL = QP.get('minscol') || null;
    const OV_SUBCOL  = QP.get('subcol')  || null;


    // ---------- Fallback subjects if we can't fetch the master list ----------
    const FALLBACK_SUBJECTS = [
      "English Language","English Literature","French",
      "Maths","Physics","Chemistry","Biology",
      "History","Geography"
    ];

    // ---------- Data loader: tries RPC/view/table options, falls back to DOM or MOCK ----------
    async function fetchSubjects() {
      if (!sb) return null;
      // Try a couple of common tables for the subject catalog
      const candidates = ["subjects","subject_list","app_subjects"];
      for (const tab of candidates) {
        try {
          const { data, error } = await sb.from(tab).select("name").order("name");
          if (!error && data && data.length) {
            return data.map(r => r.name);
          }
        } catch(e) {}
      }
      return null;
    }

    function adaptMinutes(row){
      return Number(
        row.minutes ?? row.duration_min ?? row.duration ?? row.actual_min ?? row.actualMin ?? row.mins ?? 0
      ) || 0;
    }
    function adaptSubject(row){
      if (OV_SUBCOL && row[OV_SUBCOL] != null) return String(row[OV_SUBCOL]);
      return String(row.subject ?? row.subject_name ?? row.sub ?? row.topic ?? row.name ?? "");
    }
    function adaptDate(row){
      if (OV_DATECOL && row[OV_DATECOL] != null) return row[OV_DATECOL];
      return row.date ?? row.day ?? row.start_time ?? row.started_at ?? row.ts ?? row.created_at ?? null;
    }

    async function tryFetchSessions(fromISO, toISO){
      if (!sb) return null;
      if (OV_TABLE){
        try{
          const col = OV_DATECOL || 'date';
          const { data, error } = await sb.from(OV_TABLE).select("*").gte(col, fromISO).lte(col, toISO).limit(10000);
          if (!error && Array.isArray(data)) return { data, source: `${OV_TABLE}.${col}` };
        }catch(e){ /* fall through */ }
      }
      const tables = [
        {name:"sessions_actual", col:"date"},
        {name:"sessions", col:"date"},
        {name:"sessions", col:"start_time"},
        {name:"study_sessions", col:"date"},
        {name:"logs", col:"date"},
        {name:"entries", col:"date"}
      ];
      for (const t of tables){
        try{
          const { data, error } = await sb.from(t.name).select("*").gte(t.col, fromISO).lte(t.col, toISO).limit(10000);
          if (!error && Array.isArray(data)) return { data, source: `${t.name}.${t.col}` };
        }catch(e){ /* try next */ }
      }
      try{
        const { data, error } = await sb.rpc("weekly_summary", { from_date: fromISO, to_date: toISO });
        if (!error && Array.isArray(data)) return { data, source: "rpc.weekly_summary" };
      }catch(e){}
      return null;
    }

    async function fetchRecentSessions(daysBack=400){
      if (!sb) return [];
      if (OV_TABLE){
        try{
          const since = new Date(); since.setDate(since.getDate()-daysBack);
          const fromISO = since.toISOString().slice(0,10);
          const col = OV_DATECOL || 'date';
          const { data, error } = await sb.from(OV_TABLE).select("*").gte(col, fromISO).limit(20000);
          if (!error && Array.isArray(data) && data.length) return data;
        }catch(e){}
      }
      const since = new Date(); since.setDate(since.getDate()-daysBack);
      const fromISO = since.toISOString().slice(0,10);
      const tables = [
        {name:"sessions", col:"date"},
        {name:"sessions", col:"start_time"},
        {name:"sessions_actual", col:"date"},
        {name:"study_sessions", col:"date"},
        {name:"logs", col:"date"},
        {name:"entries", col:"date"}
      ];
      for (const t of tables){
        try{
          const { data, error } = await sb.from(t.name).select("*").gte(t.col, fromISO).limit(20000);
          if (!error && Array.isArray(data) && data.length) return data;
        }catch(e){}
      }
      return [];
    }

    function startOfWeek(date) { // Monday in local (IST)
      const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      const day = d.getDay();
      const deltaToMon = (day+6)%7;
      d.setDate(d.getDate()-deltaToMon);
      d.setHours(0,0,0,0);
      return d;
    }
    function endOfWeek(date) {
      const s = startOfWeek(date);
      const e = new Date(s); e.setDate(e.getDate()+6); e.setHours(23,59,59,999);
      return e;
    }

    function groupByWeekIST(rows){
      const m = new Map();
      for(const r of rows){
        const dt = adaptDate(r);
        if(!dt) continue;
        const d = new Date(dt);
        const wkStart = startOfWeek(toIST(d));
        const key = wkStart.toISOString().slice(0,10);
        const arr = m.get(key) || [];
        arr.push(r); m.set(key, arr);
      }
      return m;
    }

    function computeBestWeekSoFar(rows){
      if(!rows || !rows.length) return null;
      const grouped = groupByWeekIST(rows);
      let best = {hours: 0, from: null, to: null};
      for(const [wkStartISO, arr] of grouped.entries()){
        let mins = 0;
        for(const r of arr){ mins += adaptMinutes(r); }
        const hrs = +(mins/60).toFixed(1);
        if(hrs > best.hours){
          const from = wkStartISO;
          const d = new Date(wkStartISO);
          const toD = new Date(d); toD.setDate(toD.getDate()+6);
          const to = toD.toISOString().slice(0,10);
          best = {hours: hrs, from, to};
        }
      }
      return best;
    }

    function computeStreak(rows){
      // rows: recent sessions (>= last 120 days). We build a day-map of minutes in IST
      const map = new Map();
      for(const r of rows){
        const dt = adaptDate(r); if(!dt) continue;
        const d = toIST(new Date(dt));
        const key = isoDateIST(fromIST(new Date(d.getFullYear(), d.getMonth(), d.getDate())));
        const prev = map.get(key) || 0;
        map.set(key, prev + adaptMinutes(r));
      }
      // Count back from today IST
      let streak = 0;
      const todayIST = toIST(new Date());
      const cur = new Date(todayIST.getFullYear(), todayIST.getMonth(), todayIST.getDate());
      for(let i=0;i<365;i++){
        const key = isoDateIST(fromIST(cur));
        const mins = map.get(key) || 0;
        if(mins>0){ streak++; } else { break; }
        cur.setDate(cur.getDate()-1);
      }
      return streak;
    }

    async function loadWeeklyData(fromISO, toISO){
      try{
        let subjects = await fetchSubjects();
        const rows = await tryFetchSessions(fromISO, toISO);
        if (!rows || rows.length===0){
          throw new Error("No rows for week or table not found");
        }
        // If no subject catalog, derive from rows
        if(!subjects || !subjects.length){
          subjects = Array.from(new Set(rows.map(adaptSubject).filter(Boolean))).sort();
        }
        // Build summary by subject
        const subjRecords = subjects.map(name => ({ name, expectedH: EXPECTED_PER_SUBJECT_H, actualMin: 0 }));
        const idx = Object.fromEntries(subjRecords.map((r,i)=>[r.name,i]));
        let sessionsCount = 0;
        for(const r of rows){
          const sub = adaptSubject(r) || "Uncategorized";
          const i = (sub in idx) ? idx[sub] : (idx[sub]=subjRecords.push({name:sub, expectedH:EXPECTED_PER_SUBJECT_H, actualMin:0})-1);
          subjRecords[i].actualMin += adaptMinutes(r);
          sessionsCount++;
        }
        // Compute best week so far & streak from recent history
        const recent = await fetchRecentSessions(400);
        const best = computeBestWeekSoFar(recent) || {hours:0, from: fromISO, to: toISO};
        const streakDays = computeStreak(recent);

        // Assemble the structure expected by renderers
        return {
          subjects: subjRecords.map(r => ({ name:r.name, plannedMin: r.expectedH*60, actualMin: r.actualMin })),
          sessions: sessionsCount,
          streakDays,
          bestWeek: best,
          targetWeeklyHours: (subjRecords.length * EXPECTED_PER_SUBJECT_H)
        };
      }catch(err){
        console.warn("Weekly data load failed; using MOCK. Reason:", err);
        return null;
      }
    }

    (function init(){
      const {from, to} = getQuery();
      renderMeta(from, to);
      // Try real data; if not available, fall back to MOCK
      (async ()=>{
        const live = await loadWeeklyData(from, to);
        const DATA = live || MOCK;
        const hint = document.getElementById('dataHint');
        if (hint) { hint.textContent = live ? `Data source: ${OV_TABLE ? OV_TABLE : 'auto-detected'} (cols: ${OV_DATECOL||'date'} / ${OV_SUBCOL||'subject'} / ${OV_MINSCOL||'minutes'})` : 'Data source: MOCK (fallback)'; }
        renderKPIs(DATA, from, to);
        renderGroupedBarChart(DATA);
        renderTable(DATA);
        renderHighlights(DATA);
        setTimeout(()=>{ window.print(); }, 400);
      })();
    })();
  </script>
</body>
</html>
